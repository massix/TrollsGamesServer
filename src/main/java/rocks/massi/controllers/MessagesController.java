package rocks.massi.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import rocks.massi.authentication.AuthenticationType;
import rocks.massi.authentication.Role;
import rocks.massi.authentication.TrollsJwt;
import rocks.massi.data.Message;
import rocks.massi.data.MessagesRepository;
import rocks.massi.data.joins.UsersGroups;
import rocks.massi.data.joins.UsersGroupsRepository;
import rocks.massi.exceptions.AuthorizationException;
import rocks.massi.exceptions.InvalidMessageException;

import java.sql.Timestamp;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/v1/messages")
@CrossOrigin(allowedHeaders = {"Authorization", "Content-Type"})
public class MessagesController {

    @Autowired
    private MessagesRepository messagesRepository;

    @Autowired
    private UsersGroupsRepository usersGroupsRepository;

    @Autowired
    private TrollsJwt trollsJwt;

    private boolean messageIsValid(final Message m) {
        List<Long> fields = new LinkedList<>();
        fields.add(m.getEventId());
        fields.add(m.getGameId());
        fields.add(m.getGroupId());
        fields.add(m.getMessageId());

        // A message is valid if it's for the homepage (i.e., `id' fields are null) or if only a single field isn't null
        List<Long> result = fields.stream().filter(Objects::isNull).collect(Collectors.toList());

        return result.size() == fields.size() || result.size() == fields.size() - 1;
    }

    @PostMapping("/create")
    public Message createNewMessage(@RequestHeader("Authorization") String authorization, @RequestBody Message message) {
        TrollsJwt.UserInformation userInformation = trollsJwt.getUserInformationFromToken(authorization);

        // A message may only be created by registered members
        if (userInformation.getAuthenticationType() != AuthenticationType.JWT) {
            throw new AuthorizationException("User not authorized.");
        }

        // Set message id to null in order to have it auto-generated by the underlying db
        message.setId(null);
        message.setAuthor(userInformation.getUser());

        // Set date to now
        message.setDateTime(new Timestamp(new Date().getTime()));

        // Check that the message is valid
        if (!messageIsValid(message)) {
            throw new InvalidMessageException();
        }

        // If a message is for a group, check that the user is part of that group
        Long groupId = message.getGroupId();
        if (groupId != null) {
            UsersGroups ug = usersGroupsRepository.findOne(new UsersGroups.UsersGroupsKey(userInformation.getUser(), groupId));
            if (ug == null) {
                throw new AuthorizationException("User not authorized");
            }
        }

        // TODO: same check should exist for events!

        return messagesRepository.save(message);
    }

    @GetMapping("/homepage")
    public List<Message> getMessagesForHomepage(@RequestHeader("Authorization") String authorization) {
        TrollsJwt.UserInformation userInformation = trollsJwt.getUserInformationFromToken(authorization);

        // Only registered users may see the messages for the homepage
        if (userInformation.getAuthenticationType() != AuthenticationType.JWT) {
            throw new AuthorizationException("User not authorized.");
        }

        // TODO: pagination, maybe?

        return messagesRepository.findAllForHomepage();
    }

    @GetMapping("/group/{id}")
    public List<Message> getMessagesForGroup(@RequestHeader("Authorization") String authorization,
                                             @PathVariable("id") Long groupId) {
        TrollsJwt.UserInformation userInformation = trollsJwt.getUserInformationFromToken(authorization);

        // Only users subscribed to the group may see its messages
        UsersGroups usersGroups = usersGroupsRepository.findOne(
                new UsersGroups.UsersGroupsKey(userInformation.getUser(), groupId));
        if (usersGroups == null && userInformation.getRole() != Role.ADMIN) {
            throw new AuthorizationException("User not authorized.");
        }

        return messagesRepository.findByGroupIdOrderByDateTimeDesc(groupId);
    }

    @GetMapping("/game/{id}")
    public List<Message> getMessagesForGame(@PathVariable("id") Long gameId) {
        // All users, even unregistered ones, may see messages for games
        return messagesRepository.findByGameIdOrderByDateTimeDesc(gameId);
    }

    @GetMapping("/message/{id}")
    public List<Message> getMessagesForMessage(@RequestHeader("Authorization") String authorization,
                                               @PathVariable("id") Long messageId) {
        TrollsJwt.UserInformation userInformation = trollsJwt.getUserInformationFromToken(authorization);

        // Only subscribed users can see the messages
        if (userInformation.getAuthenticationType() != AuthenticationType.JWT) {
            throw new AuthorizationException("User not authorized.");
        }

        return messagesRepository.findByMessageIdOrderByDateTimeDesc(messageId);
    }
}
